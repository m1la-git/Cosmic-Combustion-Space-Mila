package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.World;
import de.tum.cit.ase.bomberquest.texture.Animations;
import de.tum.cit.ase.bomberquest.texture.Drawable;
import de.tum.cit.ase.bomberquest.texture.Textures;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 * Represents an enemy character in the game.
 * Enemies are mobile objects that can navigate the game map, potentially place bombs, and attempt to find and reach players.
 * They extend {@link MobileObject} and thus inherit movement capabilities and collision detection.
 * Enemies can be configured to either actively seek out players or move randomly, and also whether they can place bombs.
 */
public class Enemy extends MobileObject implements Drawable {
    /**
     * Random number generator for making decisions, such as choosing movement directions.
     */
    private final Random random = new Random();
    /**
     * Reference to the game map, allowing the enemy to perceive its surroundings and make informed decisions about movement and pathfinding.
     */
    private final GameMap map;
    /**
     * Radius around the enemy within which it will detect players and start pathfinding towards them.
     */
    private final float DETECTION_RADIUS = 5f; // Adjust as needed
    /**
     * Threshold for considering the enemy to have reached a cell, used to handle floating-point inaccuracies and ensure smooth movement.
     */
    private final float reachedCellThreshold = 0.03f;
    /**
     * Flag determining if this enemy is capable of finding and pathfinding to the player.
     */
    private final boolean canFindPlayer;
    /**
     * Flag determining if this enemy is capable of placing bombs.
     */
    private final boolean canPlaceBombs;
    /**
     * Flag to indicate if the enemy has reached its current target cell, used for smooth movement between grid cells.
     */
    private boolean reachedCell;
    /**
     * Target x-coordinate in cell units for the enemy to move towards.
     */
    private int targetX;
    /**
     * Target y-coordinate in cell units for the enemy to move towards.
     */
    private int targetY;
    /**
     * Time elapsed since the enemy's position last changed, used to detect if the enemy is stuck.
     */
    private float nothingChangedTime = 0;
    /**
     * Previous x-coordinate of the enemy, used to detect if the enemy is moving.
     */
    private float previousX;
    /**
     * Previous y-coordinate of the enemy, used to detect if the enemy is moving.
     */
    private float previousY;
    /**
     * Flag to indicate if the enemy is trapped and unable to find a free direction to move.
     */
    private boolean trapped;
    /**
     * List of tiles representing the calculated path to the player.
     * This path is generated by the {@link Pathfinder}.
     */
    private List<Tile> pathToPlayer;
    /**
     * Index of the next tile in the {@code pathToPlayer} list that the enemy should move to.
     */
    private int pathIndex;

    /**
     * Constructs a new Enemy object.
     *
     * @param world         The Box2D world to which the enemy's hitbox will be added.
     * @param x             The starting x-coordinate of the enemy in world units.
     * @param y             The starting y-coordinate of the enemy in world units.
     * @param map           The game map that the enemy is part of.
     * @param canFindPlayer {@code true} if the enemy can detect and pathfind to players, {@code false} otherwise.
     * @param canPlaceBombs {@code true} if the enemy is capable of placing bombs, {@code false} otherwise.
     */
    public Enemy(World world, float x, float y, GameMap map, boolean canFindPlayer, boolean canPlaceBombs) {
        super(world, x, y, 1, 0.45f);
        this.map = map;
        reachedCell = true;
        trapped = false;
        this.pathToPlayer = null;
        this.pathIndex = 0;
        previousX = x;
        previousY = y;
        this.canFindPlayer = canFindPlayer;
        this.canPlaceBombs = canPlaceBombs;
    }

    /**
     * Updates the enemy's state every frame.
     * This includes movement logic, pathfinding if the player is within detection radius,
     * and handling death animation and status.
     * The enemy will either try to move towards a player if detected and pathfinding is enabled,
     * or move randomly in free directions. If the enemy gets stuck, it will attempt to change direction.
     *
     * @param frameTime The time elapsed since the last frame in seconds.
     */
    @Override
    public void tick(float frameTime) {
        increaseElapsedTime(frameTime);
        if (isAlive()) {
            nothingChangedTime += frameTime;
            // Check if the enemy has moved since the last tick
            if (Math.abs(getX() - previousX) > reachedCellThreshold || Math.abs(getY() - previousY) > reachedCellThreshold) {
                nothingChangedTime = 0; // Reset stuck timer if moved
                previousX = getX();
                previousY = getY();
            }
            // If enemy hasn't moved for a while, consider it stuck and force a direction recalculation
            if (nothingChangedTime >= 0.2f) {
                nothingChangedTime = 0;
                reachedCell = true;
                pathToPlayer = null; // Invalidate path to recalculate or choose new direction
            }
            // If target cell or current cell becomes blocked, invalidate path and recalculate direction
            if (!map.isCellFree(targetX, targetY) || !map.isCellFree(getCellX(), getCellY())) {
                pathToPlayer = null;
                reachedCell = true;
            }
            // If enemy is far from target cell even after some time, force recalculation
            if (Math.abs(getX() - targetX) > 1f - reachedCellThreshold && Math.abs(getY() - targetY) > 1f - reachedCellThreshold && nothingChangedTime > 0.3) {
                reachedCell = true;
                pathToPlayer = null;
            }

            // Snap enemy to grid cell if close enough to target cell to ensure grid alignment
            if (Math.abs(getX() - targetX) < reachedCellThreshold && Math.abs(getY() - targetY) < reachedCellThreshold) {
                reachedCell = true;
                getHitbox().setTransform(getCellX(), getCellY(), getHitbox().getAngle());
            }

            // Calculate distances to player 1 and player 2 (if exists)
            float distanceToPlayer1 = Vector2.dst(getX(), getY(), map.getPlayer1().getX(), map.getPlayer1().getY());
            float distanceToPlayer2 = (map.getPlayer2() != null) ? Vector2.dst(getX(), getY(), map.getPlayer2().getX(), map.getPlayer2().getY()) : -1;

            // Check if any player is within detection radius and if enemy can pathfind
            if ((distanceToPlayer1 < DETECTION_RADIUS || (distanceToPlayer2 < DETECTION_RADIUS && distanceToPlayer2 >= 0)) && canFindPlayer) {
                if (reachedCell) { // Only recalculate path or choose new direction if reached the cell
                    if (pathToPlayer == null || pathToPlayer.isEmpty()) {
                        if (distanceToPlayer1 < DETECTION_RADIUS)
                            findPathToPlayer(map.getPlayer1()); // Pathfind to player 1 if closer or player 2 doesn't exist
                        else findPathToPlayer(map.getPlayer2()); // Otherwise pathfind to player 2
                    }
                    if (pathToPlayer != null && !pathToPlayer.isEmpty()) {
                        followPath(); // Follow the calculated path to the player
                    } else {
                        // If no path found, fall back to random movement
                        setDirection(selectFreeDirection());
                        if (!trapped) {
                            reachedCell = false; // Allow movement in the new random direction
                        }
                    }
                }
                moveInDirection(); // Move in the determined direction (path following or random)
            } else {
                pathToPlayer = null; // Player is out of range, clear any existing path
                // Player is out of range, resume random movement
                if (reachedCell) {
                    setDirection(selectFreeDirection()); // Choose a new random direction
                    if (!trapped) {
                        reachedCell = false; // Allow movement in the new random direction
                    }
                }
                moveInDirection(); // Move in the randomly chosen direction
            }
        } else if (!isAlive() && getElapsedTime() >= 1.05f && !isDead()) setDead(); // Handle death animation completion
    }

    /**
     * Finds and sets the path to the specified player using the {@link Pathfinder}.
     *
     * @param player The player to find a path to.
     */
    private void findPathToPlayer(Player player) {
        Tile startTile = new Tile(getCellX(), getCellY()); // Enemy's current tile
        Tile targetTile = new Tile(player.getCellX(), player.getCellY()); // Player's current tile
        this.pathToPlayer = Pathfinder.findPath(startTile, targetTile, map); // Calculate path
        this.pathIndex = 0; // Reset path index for new path
    }

    /**
     * Moves the enemy along the calculated path to the player.
     * Follows the {@code pathToPlayer} list, moving towards each tile in sequence.
     * If the path is blocked or completed, it resets the path.
     */
    private void followPath() {
        if (pathToPlayer != null && pathIndex < pathToPlayer.size()) {
            Tile nextTile = pathToPlayer.get(pathIndex); // Get the next tile in the path
            int nextTargetX = nextTile.x();
            int nextTargetY = nextTile.y();

            // Check if the next tile in the path is now blocked (e.g., by a bomb)
            if (!map.isCellFree(nextTargetX, nextTargetY)) {
                pathToPlayer = null; // Invalidate the current path if blocked
                return; // Recalculate the path in the next tick
            }

            if (reachedCell) {
                DirectionType nextDirection = getDirectionToTarget(nextTargetX, nextTargetY); // Determine direction to next tile
                setDirection(nextDirection); // Set the direction for movement
                updateTargetCellFromCoords(nextTargetX, nextTargetY); // Update target cell to the next tile
                reachedCell = false; // Moved, so not at the new target yet
            }

            // Continue moving if not yet reached the target of the current step
            if (getDirection() != DirectionType.NONE) {
                moveInDirection(); // Initiate movement in the determined direction
            }

            // Check if the current target cell for this step is reached
            if (Math.abs(getX() - targetX) < reachedCellThreshold && Math.abs(getY() - targetY) < reachedCellThreshold) {
                getHitbox().setTransform(getCellX(), getCellY(), getHitbox().getAngle()); // Snap to grid for alignment
                reachedCell = true;
                pathIndex++; // Move to the next step in the path
            }

        } else {
            pathToPlayer = null; // Path completed or invalid, reset path
        }
    }

    /**
     * Determines the direction to move to reach a target cell from the enemy's current cell.
     *
     * @param targetCellX The x-coordinate of the target cell.
     * @param targetCellY The y-coordinate of the target cell.
     * @return The {@link DirectionType} to move towards the target cell, or {@link DirectionType#NONE} if already at the target.
     */
    private DirectionType getDirectionToTarget(int targetCellX, int targetCellY) {
        int currentCellX = getCellX();
        int currentCellY = getCellY();

        if (targetCellX > currentCellX) {
            return DirectionType.RIGHT;
        } else if (targetCellX < currentCellX) {
            return DirectionType.LEFT;
        } else if (targetCellY > currentCellY) {
            return DirectionType.UP;
        } else if (targetCellY < currentCellY) {
            return DirectionType.DOWN;
        } else {
            return DirectionType.NONE; // Already at the target
        }
    }

    /**
     * Selects a random free direction for the enemy to move in.
     * Prioritizes directions that are not the immediate opposite of the current direction to avoid oscillating movement.
     * If no free direction is found, the enemy may be considered trapped.
     * If the enemy isn't trapped and can place bombs, it might place a bomb in its current location.
     *
     * @return The selected {@link DirectionType}, or the current direction if no free direction is found.
     */
    private DirectionType selectFreeDirection() {
        DirectionType[] directions = {DirectionType.UP, DirectionType.DOWN, DirectionType.LEFT, DirectionType.RIGHT};
        List<DirectionType> freeDirections = new ArrayList<>();

        DirectionType fallbackDirection = DirectionType.getOppositeDirection(getDirection()); // Avoid turning back immediately

        // Collect all free directions that are not the fallback direction
        for (DirectionType direction : directions) {
            if (isDirectionFree(direction) && direction != fallbackDirection) {
                freeDirections.add(direction);
            }
        }

        // If there are free directions, choose one randomly
        if (!freeDirections.isEmpty()) {
            DirectionType direction = freeDirections.get(random.nextInt(freeDirections.size()));
            updateTargetCell(direction); // Update target cell based on direction
            setDirection(direction); // Set the chosen direction
            trapped = false; // No longer trapped as a free direction is found
            return direction;
        }

        // If no other free direction, try the fallback direction (opposite of current direction)
        if (isDirectionFree(fallbackDirection)) {
            updateTargetCell(fallbackDirection); // Update target cell for fallback direction
            setDirection(fallbackDirection); // Set direction to fallback
            if (!trapped && canPlaceBombs) map.placeBomb(this); // If not trapped and can place bombs, place one
            trapped = false; // Moving, so not trapped anymore
            return fallbackDirection;
        }

        trapped = true; // No free directions found, enemy is trapped
        return getDirection(); // Stay in the current direction (which is likely NONE if stuck)
    }

    /**
     * Updates the enemy's target cell based on a chosen direction.
     *
     * @param direction The {@link DirectionType} in which to move.
     */
    private void updateTargetCell(DirectionType direction) {
        int[] targetCellCoords = coordsPossibleTargetCell(direction); // Get potential target cell coords
        targetX = targetCellCoords[0];
        targetY = targetCellCoords[1];
    }

    /**
     * Updates the enemy's target cell directly using provided coordinates.
     *
     * @param x The x-coordinate of the target cell.
     * @param y The y-coordinate of the target cell.
     */
    private void updateTargetCellFromCoords(int x, int y) {
        targetX = x;
        targetY = y;
    }

    /**
     * Checks if moving in a given direction would lead to a free (non-blocked) cell.
     *
     * @param direction The {@link DirectionType} to check.
     * @return {@code true} if the cell in the given direction is free, {@code false} otherwise.
     */
    private boolean isDirectionFree(DirectionType direction) {
        int[] targetCellCoords = coordsPossibleTargetCell(direction); // Get potential target cell coords
        return map.isCellFree(targetCellCoords[0], targetCellCoords[1]); // Check if the cell is free on the map
    }

    /**
     * Calculates the coordinates of a potential target cell based on the current cell and a given direction.
     *
     * @param direction The {@link DirectionType} to move in.
     * @return An array of two integers representing the x and y coordinates of the potential target cell.
     */
    private int[] coordsPossibleTargetCell(DirectionType direction) {
        int targetCellX = getCellX();
        int targetCellY = getCellY();
        switch (direction) {
            case UP:
                targetCellY += 1;
                break;
            case DOWN:
                targetCellY -= 1;
                break;
            case LEFT:
                targetCellX -= 1;
                break;
            case RIGHT:
                targetCellX += 1;
                break;
        }
        return new int[]{targetCellX, targetCellY};
    }

    /**
     * Gets the current texture region representing the enemy's appearance.
     * The appearance changes based on the enemy's last movement direction for animation purposes,
     * and switches to a death animation when the enemy is not alive.
     *
     * @return The current {@link TextureRegion} for rendering the enemy.
     */
    @Override
    public TextureRegion getCurrentAppearance() {
        if (isAlive()) {
            return switch (getLastDirection()) {
                case UP -> Animations.ENEMY_WALK_UP.getKeyFrame(getElapsedTime(), true); // Walking up animation
                case RIGHT ->
                        Animations.ENEMY_WALK_RIGHT.getKeyFrame(getElapsedTime(), true); // Walking right animation
                case LEFT -> Animations.ENEMY_WALK_LEFT.getKeyFrame(getElapsedTime(), true); // Walking left animation
                case DOWN -> Animations.ENEMY_WALK_DOWN.getKeyFrame(getElapsedTime(), true); // Walking down animation
                case NONE -> Textures.ENEMY; // Default texture when not moving
            };
        }
        return Animations.ENEMY_DEATH.getKeyFrame(getElapsedTime(), false); // Death animation
    }
}