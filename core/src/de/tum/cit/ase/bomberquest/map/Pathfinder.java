package de.tum.cit.ase.bomberquest.map;

import java.util.*;

/**
 * Utility class for pathfinding in the game map using Breadth-First Search (BFS) algorithm.
 * This class provides a static method {@link #findPath(Tile, Tile, GameMap)} to calculate the shortest path
 * between a start and a target tile on a given {@link GameMap}. It uses BFS to explore the map and find a valid path,
 * considering only free cells as traversable.
 */
public class Pathfinder {
    /**
     * Finds the shortest path between a start tile and a target tile on the game map using Breadth-First Search (BFS).
     * The pathfinding algorithm explores the map starting from the {@code start} tile, searching for the {@code target} tile.
     * It uses BFS to guarantee finding the shortest path if one exists. The algorithm considers only cells that are marked as free
     * in the {@code GameMap} and avoids already visited tiles to prevent cycles and redundant searches.
     *
     * @param start  The starting {@link Tile} for pathfinding.
     * @param target The target {@link Tile} to reach.
     * @param map    The {@link GameMap} on which to perform pathfinding. This map provides information about cell availability and map boundaries.
     * @return A {@link List} of {@link Tile} objects representing the shortest path from the start to the target tile, inclusive of start and target.
     * Returns {@code null} if no path is found between the start and target tiles (e.g., target is unreachable).
     */
    public static List<Tile> findPath(Tile start, Tile target, GameMap map) {
        Queue<Tile> queue = new LinkedList<>(); // Queue for BFS exploration
        Set<Tile> visited = new HashSet<>(); // Set to keep track of visited tiles
        Map<Tile, Tile> parentMap = new HashMap<>(); // Map to store the parent of each tile in the path

        queue.offer(start); // Start BFS from the start tile
        visited.add(start); // Mark start tile as visited
        parentMap.put(start, null); // Start tile has no parent

        while (!queue.isEmpty()) {
            Tile currentTile = queue.poll(); // Get the next tile to explore from the queue

            if (currentTile.equals(target)) {
                return reconstructPath(parentMap, target); // Target reached, reconstruct and return the path
            }

            int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movement directions (up, down, right, left)
            for (int[] dir : directions) {
                int newX = currentTile.x() + dir[0]; // Calculate neighbor's x coordinate
                int newY = currentTile.y() + dir[1]; // Calculate neighbor's y coordinate
                Tile neighbor = new Tile(newX, newY); // Create a Tile object for the neighbor

                // Check if the neighbor is within map bounds, is a free cell, and has not been visited yet
                if (newX >= 0 && newX < map.getMAX_X() && newY >= 0 && newY < map.getMAX_Y() &&
                        map.isCellFree(newX, newY) && !visited.contains(neighbor)) {
                    queue.offer(neighbor); // Add neighbor to the queue for exploration
                    visited.add(neighbor); // Mark neighbor as visited
                    parentMap.put(neighbor, currentTile); // Set current tile as parent of the neighbor in the path
                }
            }
        }
        return null; // No path found after exploring all reachable tiles
    }

    /**
     * Reconstructs the path from the target tile back to the start tile using the parent map generated by BFS.
     * This method traces back from the {@code target} tile to the {@code start} tile using the parent pointers stored
     * in the {@code parentMap}. It builds a list of tiles representing the path in reverse order and then reverses it to get
     * the path from start to target.
     *
     * @param parentMap A {@link Map} that stores each tile's parent tile in the path, as determined by the BFS algorithm.
     * @param target    The target {@link Tile} from which to reconstruct the path back to the start.
     * @return A {@link List} of {@link Tile} objects representing the reconstructed path from the start to the target tile.
     */
    private static List<Tile> reconstructPath(Map<Tile, Tile> parentMap, Tile target) {
        List<Tile> path = new ArrayList<>(); // List to store the reconstructed path
        Tile current = target; // Start reconstruction from the target tile
        while (current != null) {
            path.add(0, current); // Add current tile to the beginning of the path list (building path in reverse)
            current = parentMap.get(current); // Move to the parent tile
        }
        return path; // Return the reconstructed path (now in correct start-to-target order)
    }
}